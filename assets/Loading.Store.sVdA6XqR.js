let a=[],s=0;const f=4;let d=i=>{let t=[],e={get(){return e.lc||e.listen(()=>{})(),e.value},lc:0,listen(l){return e.lc=t.push(l),()=>{for(let o=s+f;o<a.length;)a[o]===l?a.splice(o,f):o+=f;let n=t.indexOf(l);~n&&(t.splice(n,1),--e.lc||e.off())}},notify(l,n){let o=!a.length;for(let c of t)a.push(c,e.value,l,n);if(o){for(s=0;s<a.length;s+=f)a[s](a[s+1],a[s+2],a[s+3]);a.length=0}},off(){},set(l){let n=e.value;n!==l&&(e.value=l,e.notify(n))},subscribe(l){let n=e.listen(l);return l(e.value),n},value:i};return e},m=(i={})=>{let t=d(i);return t.setKey=function(e,l){let n=t.value;typeof l>"u"&&e in t.value?(t.value={...t.value},delete t.value[e],t.notify(n,e)):t.value[e]!==l&&(t.value={...t.value,[e]:l},t.notify(n,e))},t};const u=m({G_all:!1,G_fetch:!1}),r=(i,t)=>{u.setKey(i,t)},v=async(i,t)=>{const e=t?.id||"G_fetch";if(u.get()[e]){console.warn(`Promise for ${e} is already running.`);return}try{r(e,!0),t?.delayIn&&await new Promise(l=>setTimeout(l,t.delayIn)),await i()}catch(l){console.error(`Error in Loading.promise for ${e}:`,l)}finally{await new Promise(l=>setTimeout(()=>{r(e,!1),l()},t?.delayOut||0))}},g={set:r,start:i=>r(i,!0),end:i=>r(i,!1),promise:v};export{u as $,g as L,d as a,m};
